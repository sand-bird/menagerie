extends Node
class_name Action
"""
basic behavior tree style action. has two active methods, "proc" and "tick".
the former runs on the physics clock, and the latter runs every in-game tick.

all actions have, at minimum, a reference to the monster performing the action
and a timeout value (to avoid infinite loops). action subclasses often take in
addition parameters like a target.
"""

signal exited(status)

enum Status {
	NEW = 0,
	RUNNING = 1,
	SUCCESS = 2,
	FAILED = 3,
	PAUSED = 4
}

static func get_status(status_code):
	return ['new', 'running', 'success', 'failed'][status_code]

# reference to the monster running the action
var m: Monster
var status := Status.NEW
# time remaining, decremented every tick. when this hits 0 we call _timeout().
var t: int = Clock.TICKS_IN_HOUR * 3
# real milliseconds (not ticks) during which the action is paused, set with
# sleep(). not sure if we'll ever actually need this.
var sleep_timer: int = 0

# --------------------------------------------------------------------------- #

func _init(monster, timeout = null):
	m = monster
	if timeout != null: t = timeout


# =========================================================================== #
#                                U T I L I T Y                                #
# --------------------------------------------------------------------------- #
# methods to help a monster figure out the utility value of the action, via the
# static Decider class. called after an action is instantiated but before it is
# run. these are implemented by the base action with default values, and can be
# reimplemented by subclasses as needed.

# return an estimation of the action's effect on the monster's drives, which is
# used by the Decider to calculate the action's utility.  result should be the
# amount by which the action is expected to increase or decrease the drive
# (negative for a decrease).
func estimate_mood() -> float: return 0
func estimate_belly() -> float: return 0
func estimate_energy() -> float: return 0
func estimate_social() -> float: return 0

# takes in the utility value generated by the Decider, based on the output of
# the `estimate_{drive}` functions above, and returns a new utility value.
# can be used to modify the calculated utility value or simply override it. 
func mod_utility(utility: float): return utility


# =========================================================================== #
#                              E X E C U T I O N                              #
# --------------------------------------------------------------------------- #
#                    t o p - l e v e l   e x e c u t i o n                    #
# --------------------------------------------------------------------------- #
# lifecycle methods shared by all actions.
# these should NOT overridden by action subclasses.

func start():
	Log.verbose(self, ['(start) timeout: ', t])
	status = Status.RUNNING
	_start()

# --------------------------------------------------------------------------- #

func unpause():
	Log.verbose(self, ['(unpause) timeout: ', t])
	status = Status.RUNNING
	_unpause()

# --------------------------------------------------------------------------- #

func proc(delta):
	if status == Status.NEW: start()
	if status == Status.PAUSED: unpause()
	if status != Status.RUNNING: return
	if sleep_timer:
		sleep_timer -= 1
	else:
		_proc(delta)

# --------------------------------------------------------------------------- #

# returns an `action_result`, a dict containing a drive delta for each of our
# four drives.
func tick():
	if status == Status.NEW: start()
	if status == Status.PAUSED: unpause()
	if status != Status.RUNNING: return
	t -= 1
	if t <= 0: _timeout()
	else: return _tick()

# --------------------------------------------------------------------------- #

func exit(exit_status):
	status = exit_status
	Log.verbose(self, ['(exit) status: ', status])
	exited.emit(status)
	return status

# --------------------------------------------------------------------------- #

# sleep for a certain number of ticks
func sleep(duration):
	if duration > 0:
		sleep_timer = duration


#              a c t i o n - s p e c i f i c   e x e c u t i o n              #
# --------------------------------------------------------------------------- #
# internal methods called by top-level execution above.
# these should be implemented by subclasses.

# called from public method start() when the action should start running
func _start(): pass

func _unpause(): _start()

# called each ingame tick
func _tick(): pass

# called each process update
func _proc(_delta): pass

# behavior when the timeout expires. all actions need a timeout to prevent
# infinite loops. by default the action fails, but this can be overridden by
# subclasses.
func _timeout():
	exit(Status.FAILED)
